* refactoring
** TODO harmonize clean/opt/optimize-duplicates
** minor refactoring
*** TODO use of axes/parameters
*** TODO rewrite-quads-block vs. list vs. cdr vs. quads block...
*** TODO abstract UNION-if->1 elements
* basic logic
** TODO simplifying over UNIONs
    generalize optimize-duplicates, group-graph-statements et al.
    for UNIONs we could do a `collect-duplicates-over-union`
    
** TODO does rw/union distinguish between false and empty true?
** DONE duplicates in OPTIONAL constraints
   do level-quads and the whole bit on appending constraints
** DONE simplify duplicate VALUES as well as quads
   ... possibl?elo
** DONE OPTIONALS and update constraints that *should* be inside them
   what about something like this:
   
   #+BEGIN_SRC
    DELETE {
      ?s ?p ?o . 
      ?s <D> ?dataset 
    }
    WHERE { 
      ?s ?p ?o.
      OPTIONAL { ?s <D> ?dataset . }
    }
   #+END_SRC
   
   the constraint on ?s <D> ?dataset will be outside of the OPTIONAL statement.

   two solutions:
   - instantiate-w/o-union for DELETE queries
   - put DELETE constraints in an OPTIONAL (what about INSERTs... similar logic?)
     or should it be an OPTIONAL per triple-constraint?
** TODO harmonize optimize-duplicates with optimizations' this/next-level-quads
   possible?
** DONE read/write constraints doesn't work when the same triple is in insert/delete and where blocks
   DELETE { ?s ?p ?o } WHERE { ?s ?p ?o }
	
** DONE rethink logic of functional property optimization in OPTIONAL
** DONE Too many nested lists levels
* instantiation
** TODO careful with complicated statements wrt expand-graphs
    mixing graphs, OPTIONAL, annotations...
** TODO implement a version of (instantiate ..) without UNION
    ie for DELETE queries (exact triple not needed), and also for a delta-subscription
    service like Esteban wanted

** DONE get instantiation logic correct
   including find-triples-graphs, instantiated-values, etc.

** DONE is instantiation correct for DELETE+INSERT queries?
    for the DELETE part, probably should *not* instantiate...
    maybe divide into 2 queries?

** DONE [#A] edge cases
    what *should* happen in these cases?

    the most troubling:

    #+BEGIN_SRC
    insert { ?s a ex:Frog }
    delete { ?s a ex:Prince }
    where { ?s a ex:Prince }
    #+END_SRC

    #+BEGIN_SRC
    insert { ?s a school:Class }
    where { ?s a school:Class }
    #+END_SRC

    currently rewrites to:

    #+BEGIN_SRC
    INSERT {
      GRAPH ?graph15098 {
      ?s rdf:type school:Class.
     }
    }
    WHERE {
     SELECT *
     WHERE {
      {
       VALUES (?graph15098) { (g:classes) }
      }
     }
    } 
    #+END_SRC

    #+BEGIN_SRC
    delete { ?s a school:Class }
    where { ?s a school:Class }
    #+END_SRC

* optimizations
** TODO query subselects
   what about
   
   (*subselect-vars* '(?graph))
   so collect binding: (?graph . (?graph123 ?graph425))

   and if
   { select ?graph ?type ?p where { ... ?type ?p ...} }
   =>
   { select ?graph123 where { ... <type> <p> ... } }
   then run query

** TODO is it possible to do something similar for `?type`?
** TODO big minor problem: what if SELECT ?type and ?type is optimized?
   silly example, but could there be realistic examples of this?
   select ?t where { ?s a ?t . ?s a <school> }
** TODO functional property optimization should introspect into GRAPHs
    as in:
    (apply-optimizations '((GRAPH <G> (?s a <Car>)) (GRAPH <H> (?s a ?Car))))
    
    though this begs the question of whether functional properties apply to triples
    or quads

** DONE bug: functional properties incorrect for types in OPTIONALS and UNIONS
* dependencies
** TODO FILTER dependencies
   what should the dependencies of FILTER( ?b != mu:uuid ) be??
 
** TODO verify logic of graphs + non-bound vars
   graph ?g { ?a ?b ?c . ?a ?other ?vars }
   => ?g depends on ?a, ?other and ?vars but not ?b and ?c
   because ?a ?b ?c is the "bound" triple

** DONE singleton VALUES statements for ?graph 
   #+BEGIN_SRC
    CONSTRUCT { ?s ?p ?o }
    WHERE {
      {
        GRAPH ?graph { ?s ?p ?o }
        VALUES ?graph { <G1> <G2> }
        FILTER ( ?p != mu:uuid )
      }
      UNION
      {
        GRAPH ?graph { ?s ?p ?o }
        VALUES ( ?graph ?p ) { <GRAPHS/UUID> mu:uuid }
      }
    }
   #+END_SRC
   
   Here, ?graph is not exclusively determined, so updates are not well-defined, unless
   a triple is meant to go into all graphs. But how to define SELECT queries such as:
   
   #+BEGIN_SRC
    SELECT *
    WHERE { ?a ?b ?c . ?d ?e ?f }
   #+END_SRC
   
   Can ?a ?b ?c and ?d ?e ?f come from different graphs, i.e., ?graph depends on ?s, ?p and ?o?
   The current assumptions mean that they must be in the same graph for the query to succeed.
   
** TODO BIND in constraint query
   
   #+BEGIN_SRC
    ?s ?p ?o
    BIND(COUNT(?o) AS ?count)
   #+END_SRC
   
   when ?o is substituted with a value:
   
   #+BEGIN_SRC
    ?s ?p <property>
    BIND(COUNT(<property>) AS ?count)
   #+END_SRC
   
   One solution(?):
   
   #+BEGIN_SRC
    ?s ?p <property>
    BIND(COUNT(<property>) AS ?count)
   #+END_SRC
   
** TODO clean up and rename and document dependency functions for easier code maintenance
   'cause it's a mess
* cache keys and annotations
** TODO bug: VALUES + UNIONS gives wrong results
   CONSTRUCT {
     ?a ?b ?c
   }
   WHERE {
   { 
     @access Class(?graph)
     GRAPH ?graph { 
     ?a ?b ?c .
     ?a a ?type
     }
     VALUES (?graph ?type) { (g:classes school:Class)  }
   } UNION {
   @access Person(?graph)
   GRAPH ?graph { 
     ?a ?b ?c .
     ?a a ?type
   }
   VALUES (?graph ?type) { (g:people foaf:Person) }
  }
 }
** DONE bug: top-level annotation breaks optimizations
    where { @access toplevel . GRAPH ?graph { @access inner. s p o ... } }
    
** DONE finish integrating
    - [X] group-graphs
    - [X] expand-graphs
    - [X] find-triples-graphs (funny insert with top-level annotation)
** DONE get value from VALUES
   @access graph(?graph)
   and
   WHERE {
    GRAPH ?graph16366 { ?s rdf:type foaf:Person. }
    VALUES (?graph16366) { (g:people) }
   }

   should resolve to '(graph g:people)
* little things
** TODO Fix $query and make it like (headers)
* sandbox
** DONE implement separate read/write constraints
* temp graphs
** TODO handle FILTER NOT EXISTS
* performance
